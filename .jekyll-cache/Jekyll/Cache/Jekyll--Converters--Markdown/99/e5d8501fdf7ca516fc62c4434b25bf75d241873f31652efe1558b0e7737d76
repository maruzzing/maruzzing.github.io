I"<p><img src="https://miro.medium.com/max/1200/1*7Bk_BqW4cKJssE3OX8YOOw.jpeg" alt="상속 cover" title="상속 cover" /></p>

<h2 id="intro">Intro</h2>

<p>JavaScript는 Prototype 기반의 언어라고 불린다. 그만큼 JavaScript를 이해하고 사용하기 위해 Prototype에 대한 이해가 중요하…………지만! 그만큼 어렵고 복잡하다…..😔
본격적으로 자바스크립트의 프로토타입에 대해 이야기 하기 전에 선행적으로 알아야 할 자바스크립트의 기본 개념들에 대해 이야기 하고자 한다.</p>

<div class="innerBox">
<ol>
<li> 자바스크립트에서 숫자, 문자열, boolean값, null, undefined 같은 기본 타입을 제 외한 모든 값은 객체이다. 따라서, 배열, 함수, 정규표현식 등 모두 객체로 표현할 수 있다.</li> 
<li> 자바스크립트에서 객체는 함수로 생성한다.</li>
<li> 모든 함수 객체의 Constructor(생성자/함수) 는 prototype이란 프로퍼티를 가지고 있으며, 이 prototype 프로퍼티는 함수로 생성되는 객체들이 원형으로 사용하는 객체를 가리킨다.</li>
<li> 자바스크립트에서 단순 대입 시
<ul>
   <li> 숫자, 문자열 : value copy(할당)</li>
   <li> 객체, 배열 : reference copy(참조)</li>
   <li> 변수를 함수의 인자(parameter)로 전달하는 것 역시 단순대입으로 동작</li>
   </ul>
</li>
</ol>
</div>

<h2 id="prototype-object">Prototype Object</h2>

<p>함수가 생성될 때, Constructor(생성자) 자격이 부여되며, Prototype Object가 생성&amp;연결된다.</p>

<ol>
  <li>Prototype : 모든 <strong>함수</strong>가 생성될 때 <strong>assignable</strong> 한 특징을 가지는 prototype이 함께 생성된다. 이는 객체로, <code class="highlighter-rouge">Constructor</code>와 <code class="highlighter-rouge">__proto__</code> 속성을 가지고 있다.</li>
  <li>Constructor : instance를 만들 수 있는 함수는 Constructor를 가지고 있으며, 함수의 Constructor는 자기 자신이다.</li>
</ol>

<p><img src="https://miro.medium.com/max/1400/1*Mge2Toq24VR1-PgnJsK0pQ.png" alt="Prototype Object" width="350em" /></p>

<h2 id="__proto__-vs-prototype">__proto__ vs prototype</h2>

<h3 id="__proto__">__proto__</h3>

<p>instance의 <code class="highlighter-rouge">__proto__</code>는 <strong>조상함수의 prototype object</strong>를 가리킨다. 즉, 조상함수의 prototype은 instance의 원형이 되는 객체이며, 자식 객체들이 모두 공유하는 속성이다.</p>

<p><img src="https://miro.medium.com/max/1400/1*wPQJCBzJojayIVMZgokEpA.png" alt="__proto__" width="350em" /></p>

<h3 id="prototype-chain">Prototype Chain</h3>

<p>아래 예제에서, Human 함수에 toString()이라는 method를 정의하지 않았지만, Human 함수로 생성된 객체 steve에 toString()이 실행된다. 왜?!</p>

<p><img src="https://miro.medium.com/max/1400/1*QTI0vjIQx6Wbn30pD8Amww.png" alt="Prototype" width="300em" /></p>

<p>객체는 <code class="highlighter-rouge">__proto__</code> 속성을 통해 상위 프로토타입과 연결되어 있는데, 모든 객체는 결국 Object의 prototype object를 공유하고 있으며, 그 속성을 상속받는다. 이러한 연결을 <strong>Prototype Chain</strong>이라고 한다.</p>

<p><img src="https://miro.medium.com/max/1400/1*HSp-wSe4sy16nT7BLffflQ.png" alt="Prototype Chain" width="500em" /></p>

<p><img src="https://miro.medium.com/max/1400/1*vbuE4tBZntn-bDIntpJwKw.png" alt="Prototype Chain" width="100%" /></p>

<h3 id="prototype-assign-하기">prototype assign 하기!</h3>

<p>prototype은 assign 될 수 있으므로, 한 constructor가 다른 constructor의 속성을 상속받게 할 수 있다.</p>

<ul>
  <li>case ) sleep()을 할 수 있는 Human과, learn()을 할 수 있는 Student가 있다. 이 때, Student도 sleep()을 할 수 있게 하고싶다면?</li>
</ul>

<p><strong>wrong.</strong> Student.prototype = Human.prototype</p>

<p><img src="https://miro.medium.com/max/1400/1*JfBDoKkyTAa9m7wLsr3zAA.png" alt="" /></p>

<p>이 경우, Student는 sleep만 할 수 있게 된다.</p>

<hr />

<p><strong>wrong.</strong> Student.prototype = Human.prototype 한 상태에서, Student.prototype에 learn() 함수를 추가정의하면?</p>

<p><img src="https://miro.medium.com/max/1400/1*wXgSWpeFheO-MnKszBSr9g.png" alt="" /></p>

<p>이경우, Student는 필요조건을 만족하지만, 모든 Human이 learn 할 수 있게 되는 문제가 생긴다.</p>

<hr />

<p><strong>★</strong> Human.prototype을 바로 Student.prototype에 assign 하는 것이 아니라, 복사해오면 어떨까? 이때 쓸 수 있는 것이 Object.create() 이다!</p>

<p><img src="https://miro.medium.com/max/1400/1*Ck1NHG8naImvdxAS8X-KPA.png" alt="" /></p>

<p>하지만 이 경우, Human의 prototype을 모두 복사해 왔으므로, Student의 <strong>constructor가 Student가 아닌 Human이 된다. 따라서, constructor를 Student라고 명시해 주는 추가 단계가 필요하다.!</strong></p>

<p><img src="https://miro.medium.com/max/718/1*zA1HojSpOQCVPSJxQfmILA.png" alt="assign" width="350em" /></p>

<p>또한, new 키워드로 객체 생성 시, <strong>instance마다 this가 각각 생기므로, this를 명시해줘야 properties가 제대로 상속된다.</strong></p>

<p><img src="https://miro.medium.com/max/1400/1*vSht6JfLYEfhONhai000oQ.png" alt="" /></p>

<p>드디어! prototype chain이 완성되었다!</p>

<p><img src="https://miro.medium.com/max/498/1*HD_MMPAv55-XaWGU488vxg.png" alt="assign" width="250em" /></p>

<p><strong>덧붙여,</strong> ES6 에서는 위의 복잡한 상속을 Class 와 Super 키워드로 간단하게 구현할 수 있게 되었다. Class와 Super 키워드에 대한 것은 coming soon!</p>

<h2 id="헷갈렸던-개념">+헷갈렸던 개념</h2>

<p>properties와 prototype은 다르다. properties는 new로 객체 생성 시, constructor가 실행하는 것.</p>

<p><img src="https://miro.medium.com/max/706/1*1soVUcH2Tx7h9zb2GJ8Izw.png" alt="assign" width="350em" /></p>

<p>여기서 Grub.prototype에 age, color, food와 같은 properties 까지 있다고 생각하면 안된다. prototype에는 eat()만 추가시켜 주었다!</p>

<p><img src="https://miro.medium.com/max/902/1*DdMD2k4Bm7T8LhulziT8yQ.png" alt="assign" width="450em" /></p>
:ET